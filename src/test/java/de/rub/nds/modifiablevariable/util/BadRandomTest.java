/*
 * ModifiableVariable - A Variable Concept for Runtime Modifications
 *
 * Ruhr University Bochum, Paderborn University, Technology Innovation Institute, and Hackmanit GmbH
 *
 * Licensed under Apache License 2.0 http://www.apache.org/licenses/LICENSE-2.0
 */
package de.rub.nds.modifiablevariable.util;

import static org.junit.jupiter.api.Assertions.*;

import java.util.Random;
import org.junit.jupiter.api.Test;

/** Tests for the {@link BadRandom} class. */
class BadRandomTest {

    @Test
    void testDefaultConstructor() {
        BadRandom badRandom = new BadRandom();

        // The underlying Random should be initialized with seed 0
        BadRandom badRandom2 = new BadRandom();

        // Both should generate the same sequence
        for (int i = 0; i < 10; i++) {
            assertEquals(badRandom.nextInt(), badRandom2.nextInt());
        }
    }

    @Test
    void testConstructorWithRandom() {
        // Create a BadRandom with two different Random instances with the same seed
        Random random1 = new Random(42);
        BadRandom badRandom1 = new BadRandom(random1);

        Random random2 = new Random(42);
        BadRandom badRandom2 = new BadRandom(random2);

        // Both should produce identical values
        for (int i = 0; i < 5; i++) {
            assertEquals(badRandom1.nextInt(), badRandom2.nextInt());
        }
    }

    @Test
    @SuppressWarnings("deprecation")
    void testDeprecatedConstructorWithRandomAndSeed() {
        // Test that the deprecated constructor works
        // Use a fresh Random for each BadRandom to ensure we're testing functionality
        Random random1 = new Random(42);
        byte[] seed = new byte[] {1, 2, 3}; // Should be ignored
        BadRandom badRandom = new BadRandom(random1, seed);

        assertNotNull(badRandom);
        // Just verify we can get values without exceptions
        badRandom.nextInt();
        badRandom.nextBoolean();

        // Verify that the seed parameter is ignored
        // by comparing with a different seed but same random source
        Random random2 = new Random(42);
        byte[] seed2 = new byte[] {4, 5, 6}; // Different seed
        BadRandom badRandom2 = new BadRandom(random2, seed2);

        badRandom.setSeed(42); // Reset
        badRandom2.setSeed(42); // Reset

        // Values should match when reset with the same seed
        assertEquals(badRandom.nextInt(), badRandom2.nextInt());
    }

    @Test
    @SuppressWarnings("deprecation")
    void testDeprecatedConstructorWithRandomAndSpiAndProvider() {
        // Test that the deprecated constructor works
        Random random1 = new Random(42);
        BadRandom badRandom = new BadRandom(random1, null, null);

        assertNotNull(badRandom);
        // Just verify we can get values without exceptions
        badRandom.nextInt();
        badRandom.nextBoolean();

        // Test a second instance with the same seed
        Random random2 = new Random(42);
        BadRandom badRandom2 = new BadRandom(random2, null, null);

        badRandom.setSeed(42); // Reset
        badRandom2.setSeed(42); // Reset

        // Both should produce the same value after resetting the seed
        assertEquals(badRandom.nextInt(), badRandom2.nextInt());
    }

    @Test
    void testGenerateSeed() {
        BadRandom badRandom = new BadRandom();
        int numBytes = 10;
        byte[] seed = badRandom.generateSeed(numBytes);

        assertEquals(numBytes, seed.length);

        // Reset to verify deterministic behavior
        badRandom = new BadRandom();
        byte[] seedAgain = badRandom.generateSeed(numBytes);

        assertArrayEquals(seed, seedAgain, "Generated seeds should be identical with same seed");
    }

    @Test
    void testNextBytes() {
        BadRandom badRandom = new BadRandom();
        byte[] bytes = new byte[10];
        badRandom.nextBytes(bytes);

        // Reset to verify deterministic behavior
        BadRandom badRandom2 = new BadRandom();
        byte[] bytes2 = new byte[10];
        badRandom2.nextBytes(bytes2);

        assertArrayEquals(bytes, bytes2, "Generated bytes should be identical with same seed");
    }

    @Test
    void testSetSeedLong() {
        BadRandom badRandom1 = new BadRandom();
        BadRandom badRandom2 = new BadRandom();

        // Consume a value to move the sequence along
        badRandom1.nextInt();

        // Set the same seed for both
        badRandom1.setSeed(42L);
        badRandom2.setSeed(42L);

        // Both should now generate the same values
        for (int i = 0; i < 5; i++) {
            assertEquals(badRandom1.nextInt(), badRandom2.nextInt());
        }
    }

    @Test
    void testSetSeedBytes() {
        BadRandom badRandom = new BadRandom();
        // Get some values before setting the seed
        int val1 = badRandom.nextInt();

        // This method should do nothing in BadRandom
        badRandom.setSeed(new byte[] {1, 2, 3});

        // Should continue generating from the same sequence
        int val2 = badRandom.nextInt();
        assertNotEquals(val1, val2, "Random should generate different values");
    }

    @Test
    void testGetAlgorithm() {
        BadRandom badRandom = new BadRandom();
        String algorithm = badRandom.getAlgorithm();

        assertNotNull(algorithm);
        assertTrue(algorithm.contains("WARNING"), "Algorithm name should include a warning");
        assertTrue(algorithm.contains("insecure"), "Algorithm name should warn about insecurity");
    }

    @Test
    void testNumericMethods() {
        BadRandom badRandom1 = new BadRandom();
        BadRandom badRandom2 = new BadRandom();

        // Both instances should produce the same values for all methods
        assertEquals(badRandom1.nextInt(), badRandom2.nextInt());
        assertEquals(badRandom1.nextInt(100), badRandom2.nextInt(100));
        assertEquals(badRandom1.nextLong(), badRandom2.nextLong());
        assertEquals(badRandom1.nextBoolean(), badRandom2.nextBoolean());
        assertEquals(badRandom1.nextFloat(), badRandom2.nextFloat());
        assertEquals(badRandom1.nextDouble(), badRandom2.nextDouble());
        assertEquals(badRandom1.nextGaussian(), badRandom2.nextGaussian());
    }
}
